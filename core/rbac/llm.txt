# RBAC Service

## Package Purpose

The `rbac` package provides Role-Based Access Control with a policy-based authorization engine. It features a **Role Template System** for dynamic role registration, inheritance-based role hierarchies, and a lightweight policy evaluation engine. The system supports multi-tenant organizations with app-scoped and organization-scoped roles.

## Key Files

- **service.go**: Main RBAC service with policy management and role operations (392 lines)
- **bootstrap.go**: Role Registry and template system for dynamic role registration (494 lines)
- **evaluator.go**: Policy evaluation engine
- **parser.go**: Policy expression parser
- **repository.go**: Repository interfaces for roles, permissions, and policies
- **types.go**: Helper types including RoleWithPermissions, PermissionCategory, PermissionAction
- **constants.go**: Built-in role names, priorities, and descriptions
- **policy.go**: Policy and Context struct definitions
- **role.go**: Role entity definition
- **permission.go**: Permission entity definition
- **bootstrap_test.go**: Role registry and bootstrap tests
- **evaluator_test.go**: Policy evaluation tests
- **parser_test.go**: Policy parser tests

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Role Template System                      │
│  ┌─────────────┐    ┌──────────────┐    ┌───────────────────┐  │
│  │ RoleRegistry │───▶│ RoleDefinition│───▶│ RegisterRole()    │  │
│  └─────────────┘    └──────────────┘    └───────────────────┘  │
│         │                                                        │
│         ▼                                                        │
│  ┌─────────────────┐                                            │
│  │   Bootstrap()   │──▶ Creates roles, permissions, policies    │
│  └─────────────────┘                                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     Policy Evaluation Engine                     │
│  ┌────────┐    ┌────────────┐    ┌───────────┐                 │
│  │ Parser │───▶│  Policies  │───▶│ Evaluator │                 │
│  └────────┘    └────────────┘    └───────────┘                 │
│       │                                │                        │
│       ▼                                ▼                        │
│  Expression DSL            Subject/Action/Resource Match        │
└─────────────────────────────────────────────────────────────────┘
```

## Main Types/Interfaces

### RoleDefinition (Template System)
```go
type RoleDefinition struct {
    Name         string   // Role name (e.g., "superadmin", "owner", "admin", "member")
    Description  string   // Human-readable description
    Permissions  []string // Permission expressions: "action on resource" or "* on *"
    IsPlatform   bool     // Platform-level role (superadmin) vs org-level (owner, admin, member)
    InheritsFrom string   // Parent role to inherit permissions from (for role hierarchy)
    Priority     int      // Higher priority roles override lower priority (superadmin=100, owner=80, admin=60, member=40)
}
```

### RoleRegistry
```go
type RoleRegistry struct {
    roles map[string]*RoleDefinition
}

type RoleRegistryInterface interface {
    // RegisterRole registers or updates a role definition with merge semantics
    RegisterRole(role *RoleDefinition) error
    
    // GetRole retrieves a role definition by name
    GetRole(name string) (*RoleDefinition, bool)
    
    // ListRoles returns all registered role definitions
    ListRoles() []*RoleDefinition
    
    // Bootstrap applies all registered roles to the database and policy engine
    Bootstrap(ctx context.Context, db *bun.DB, rbacService *Service, platformOrgID xid.ID) error
    
    // ValidateRoleAssignment checks if a role can be assigned
    ValidateRoleAssignment(roleName string, isPlatformOrg bool) error
    
    // GetRoleHierarchy returns roles in descending priority order
    GetRoleHierarchy() []*RoleDefinition
}
```

### Policy
```go
type Policy struct {
    Subject   string   // e.g., "user", "role:admin"
    Actions   []string // e.g., ["read", "write"]
    Resource  string   // e.g., "project:*"
    Condition string   // optional condition, e.g., "owner = true"
}

type Context struct {
    Subject  string            // e.g., "user", "role:admin"
    Action   string            // e.g., "read"
    Resource string            // e.g., "project:123"
    Vars     map[string]string // context variables used by conditions
}
```

### Service
```go
type Service struct {
    mu       sync.RWMutex
    policies []*Policy
    eval     *Evaluator

    // Repositories for role and permission management
    roleRepo           RoleRepository
    permissionRepo     PermissionRepository
    rolePermissionRepo RolePermissionRepository
    userRoleRepo       UserRoleRepository
}
```

### Built-in Role Constants
```go
const (
    RoleSuperAdmin = "superadmin"  // Priority: 100, Platform-only
    RoleOwner      = "owner"       // Priority: 80
    RoleAdmin      = "admin"       // Priority: 60, Inherits from member
    RoleMember     = "member"      // Priority: 40
)
```

### Helper Types
```go
type RoleWithPermissions struct {
    *schema.Role
    Permissions []*schema.Permission
}

type RoleCustomization struct {
    Name               *string   // Override template name
    Description        *string   // Override template description
    PermissionIDs      []xid.ID  // Specific permissions to clone
    ExcludePermissions []xid.ID  // Permissions to exclude
}

type PermissionCategory string
const (
    CategoryUsers         PermissionCategory = "users"
    CategorySettings      PermissionCategory = "settings"
    CategoryOrganizations PermissionCategory = "organizations"
    CategorySessions      PermissionCategory = "sessions"
    CategoryAPIKeys       PermissionCategory = "apikeys"
    CategoryAuditLogs     PermissionCategory = "audit_logs"
    CategoryRoles         PermissionCategory = "roles"
    CategoryDashboard     PermissionCategory = "dashboard"
    CategoryCustom        PermissionCategory = "custom"
)

type PermissionAction string
const (
    ActionView    PermissionAction = "view"
    ActionCreate  PermissionAction = "create"
    ActionEdit    PermissionAction = "edit"
    ActionDelete  PermissionAction = "delete"
    ActionManage  PermissionAction = "manage"
    ActionAll     PermissionAction = "*"
)
```

## Public API

### Role Template System

#### Register Role Definition
```go
registry := NewRoleRegistry()

// Register a custom role with inheritance
err := registry.RegisterRole(&RoleDefinition{
    Name:         "moderator",
    Description:  "Content moderator",
    IsPlatform:   false,
    InheritsFrom: "member",  // Inherits member permissions
    Priority:     50,
    Permissions: []string{
        "view,edit,delete on content",
        "view on audit_logs",
    },
})
```

#### Override Existing Role (Merge Semantics)
```go
// Plugins can extend existing roles
err := registry.RegisterRole(&RoleDefinition{
    Name:        "admin",
    Permissions: []string{
        "manage on webhooks",  // Added to existing admin permissions
    },
})
// Permissions are merged, not replaced
```

#### Register Default Platform Roles
```go
// Called during AuthSome initialization
err := RegisterDefaultPlatformRoles(registry)
// Creates: superadmin, owner, admin, member with default permissions
```

#### Bootstrap Roles to Database
```go
// Called after DB migrations and plugin init
err := registry.Bootstrap(ctx, db, rbacService, platformOrgID)
// Creates:
// 1. Permission records in database
// 2. Role records in database
// 3. Policy expressions in policy engine
```

#### Validate Role Assignment
```go
// Platform roles can only be assigned in platform org
err := registry.ValidateRoleAssignment("superadmin", isPlatformOrg)
if err != nil {
    // "superadmin is a platform role and can only be assigned in the platform organization"
}
```

### Policy Management

#### Add Policy Directly
```go
rbacSvc.AddPolicy(&Policy{
    Subject:   "role:admin",
    Actions:   []string{"read", "write"},
    Resource:  "users",
    Condition: "",
})
```

#### Add Policy via Expression
```go
// Parse and add policy expression
err := rbacSvc.AddExpression("role:admin:read,write on users")
// Alternative with condition:
err := rbacSvc.AddExpression("role:editor:edit on content:* where owner = true")
```

#### Load Policies from Repository
```go
err := rbacSvc.LoadPolicies(ctx, policyRepo)
// Loads all stored policy expressions
```

### Policy Evaluation

#### Simple Authorization Check
```go
allowed := rbacSvc.Allowed(&Context{
    Subject:  "role:admin",
    Action:   "read",
    Resource: "users",
})
```

#### Authorization with User Roles
```go
// Check policies against user's assigned roles
userRoles := []string{"admin", "editor"}
allowed := rbacSvc.AllowedWithRoles(&Context{
    Subject:  "user:123",
    Action:   "edit",
    Resource: "content:456",
}, userRoles)
// Evaluates policies for "role:admin" and "role:editor"
```

#### With Condition Variables
```go
allowed := rbacSvc.Allowed(&Context{
    Subject:  "role:editor",
    Action:   "delete",
    Resource: "content:123",
    Vars: map[string]string{
        "owner": "true",
    },
})
```

### Organization Role Management

#### Bootstrap Organization Roles from Templates
```go
// Clone role templates for a new organization
templateIDs := []xid.ID{templateID1, templateID2}
customizations := map[xid.ID]*RoleCustomization{
    templateID1: {
        Name: stringPtr("Custom Admin"),
    },
}
err := rbacSvc.BootstrapOrgRoles(ctx, orgID, templateIDs, customizations)
```

#### Get Organization Roles
```go
roles, err := rbacSvc.GetOrgRoles(ctx, orgID)
// Returns all org-specific roles (cloned from templates)
```

#### Update Organization Role
```go
err := rbacSvc.UpdateOrgRole(ctx, roleID, "New Name", "New Description", permissionIDs)
// Only works for org-scoped roles, not templates
```

#### Delete Organization Role
```go
err := rbacSvc.DeleteOrgRole(ctx, roleID)
// Only works for org-scoped roles, not templates
```

#### Assign Owner Role
```go
err := rbacSvc.AssignOwnerRole(ctx, userID, orgID)
// Finds and assigns the owner role (cloned from template with is_owner_role = true)
```

### Permission Management

#### Get App Permissions
```go
perms, err := rbacSvc.GetAppPermissions(ctx, appID)
```

#### Get Org-Specific Permissions
```go
perms, err := rbacSvc.GetOrgPermissions(ctx, orgID)
```

#### Get Permissions by Category
```go
perms, err := rbacSvc.GetPermissionsByCategory(ctx, "users", appID)
```

#### Create Custom Permission
```go
perm, err := rbacSvc.CreateCustomPermission(ctx, "export_reports", "Export data reports", "custom", orgID)
```

### Role-Permission Management

#### Assign Permissions to Role
```go
err := rbacSvc.AssignPermissionsToRole(ctx, roleID, []xid.ID{permID1, permID2})
```

#### Remove Permissions from Role
```go
err := rbacSvc.RemovePermissionsFromRole(ctx, roleID, []xid.ID{permID1})
```

#### Get Role Permissions
```go
perms, err := rbacSvc.GetRolePermissions(ctx, roleID)
```

## Policy Expression Syntax

### Format
```
subject:action1,action2 on resource[:*] [where key = value]
```

### Examples
```
# Basic policy
user:read on projects

# Multiple actions
role:admin:read,write,delete on users

# Wildcard resource
role:owner:* on organization:*

# Conditional policy
role:editor:edit on content:* where owner = true

# Role subject (used with AllowedWithRoles)
role:superadmin:* on *
```

### Resource Matching
- Exact match: `users` matches `users`
- Wildcard all: `*` matches any resource
- Prefix wildcard: `content:*` matches `content:123`, `content:abc`

## Default Platform Roles

The system registers four default roles with inheritance:

### superadmin (Priority: 100)
```go
Permissions: ["* on *"]  // Unrestricted access
IsPlatform: true          // Platform org only
```

### owner (Priority: 80)
```go
Permissions: [
    "* on organization.*",
    "dashboard.view on dashboard",
    "view,edit,delete,create on users",
    "view,delete on sessions",
    "view on audit_logs",
    "manage on apikeys",
    "manage on settings",
]
```

### admin (Priority: 60, Inherits: member)
```go
Permissions: [
    "dashboard.view on dashboard",
    "view,edit,delete,create on users",
    "view,delete on sessions",
    "view on audit_logs",
    "view,create on apikeys",
    "view on settings",
]
// + all member permissions via inheritance
```

### member (Priority: 40)
```go
Permissions: [
    "dashboard.view on dashboard",
    "view on profile",
    "edit on profile",
]
```

## Role Inheritance

The system supports single inheritance with automatic permission merging:

```go
// Admin inherits from member
registry.RegisterRole(&RoleDefinition{
    Name:         "admin",
    InheritsFrom: "member",  // Inherits all member permissions
    Permissions:  []string{"manage on users"},
})

// Final admin permissions = member permissions + "manage on users"
```

### Inheritance Resolution
1. Resolves parent chain recursively
2. Detects circular dependencies (returns error)
3. Merges permissions (child + parent)
4. Child permissions override parent on conflict

## Repository Interfaces

### PolicyRepository
```go
type PolicyRepository interface {
    ListAll(ctx context.Context) ([]string, error)
    Create(ctx context.Context, expression string) error
}
```

### RoleRepository
```go
type RoleRepository interface {
    Create(ctx context.Context, role *schema.Role) error
    Update(ctx context.Context, role *schema.Role) error
    Delete(ctx context.Context, roleID xid.ID) error
    FindByID(ctx context.Context, roleID xid.ID) (*schema.Role, error)
    FindByNameAndApp(ctx context.Context, name string, appID xid.ID) (*schema.Role, error)
    ListByOrg(ctx context.Context, orgID *string) ([]schema.Role, error)
    
    // Template operations
    GetRoleTemplates(ctx context.Context, appID xid.ID) ([]*schema.Role, error)
    GetOwnerRole(ctx context.Context, appID xid.ID) (*schema.Role, error)
    
    // Organization-scoped roles
    GetOrgRoles(ctx context.Context, orgID xid.ID) ([]*schema.Role, error)
    GetOrgRoleWithPermissions(ctx context.Context, roleID xid.ID) (*schema.Role, error)
    
    // Role cloning
    CloneRole(ctx context.Context, templateID xid.ID, orgID xid.ID, customName *string) (*schema.Role, error)
}
```

### PermissionRepository
```go
type PermissionRepository interface {
    Create(ctx context.Context, permission *schema.Permission) error
    Update(ctx context.Context, permission *schema.Permission) error
    Delete(ctx context.Context, permissionID xid.ID) error
    FindByID(ctx context.Context, permissionID xid.ID) (*schema.Permission, error)
    FindByName(ctx context.Context, name string, appID xid.ID, orgID *xid.ID) (*schema.Permission, error)
    ListByApp(ctx context.Context, appID xid.ID) ([]*schema.Permission, error)
    ListByOrg(ctx context.Context, orgID xid.ID) ([]*schema.Permission, error)
    ListByCategory(ctx context.Context, category string, appID xid.ID) ([]*schema.Permission, error)
    CreateCustomPermission(ctx context.Context, name, description, category string, orgID xid.ID) (*schema.Permission, error)
}
```

### RolePermissionRepository
```go
type RolePermissionRepository interface {
    AssignPermission(ctx context.Context, roleID, permissionID xid.ID) error
    UnassignPermission(ctx context.Context, roleID, permissionID xid.ID) error
    GetRolePermissions(ctx context.Context, roleID xid.ID) ([]*schema.Permission, error)
    GetPermissionRoles(ctx context.Context, permissionID xid.ID) ([]*schema.Role, error)
    ReplaceRolePermissions(ctx context.Context, roleID xid.ID, permissionIDs []xid.ID) error
}
```

### UserRoleRepository
```go
type UserRoleRepository interface {
    Assign(ctx context.Context, userID, roleID, orgID xid.ID) error
    Unassign(ctx context.Context, userID, roleID, orgID xid.ID) error
    ListRolesForUser(ctx context.Context, userID xid.ID, orgID *xid.ID) ([]schema.Role, error)
}
```

## Dependencies

- **github.com/rs/xid**: Unique ID generation
- **github.com/uptrace/bun**: Database ORM for bootstrap
- **schema**: Database models (Role, Permission)
- **internal/errs**: Error handling

## Used By

- **authsome (root)**: Initializes RoleRegistry and calls Bootstrap
- **plugins/**: Register custom roles via RoleRegistry
- **core/organization**: Member permission checking
- **core/app**: App-level authorization
- **core/apikey**: API key scope validation
- **handlers/**: Authorization middleware
- **plugins/admin**: Admin permission checks
- **plugins/dashboard**: UI permission enforcement
- **plugins/permissions**: Advanced permission plugin

## Integration Patterns

### Plugin Role Registration
```go
// In plugin Init()
func (p *MyPlugin) Init(auth *authsome.Auth) error {
    // Register plugin-specific roles
    auth.RoleRegistry().RegisterRole(&rbac.RoleDefinition{
        Name:        "content_manager",
        Description: "Manages content",
        Permissions: []string{
            "* on content",
            "view on analytics",
        },
        Priority: 55,
    })
    
    // Extend existing roles
    auth.RoleRegistry().RegisterRole(&rbac.RoleDefinition{
        Name: "admin",
        Permissions: []string{
            "manage on content",  // Added to admin
        },
    })
    
    return nil
}
```

### Authorization Middleware
```go
func RequirePermission(rbacSvc *rbac.Service, action, resource string) forge.Middleware {
    return func(c *forge.Context) error {
        userRoles := contexts.GetUserRoles(c.Context())
        
        allowed := rbacSvc.AllowedWithRoles(&rbac.Context{
            Subject:  "user",
            Action:   action,
            Resource: resource,
        }, userRoles)
        
        if !allowed {
            return errs.PermissionDenied(action, resource)
        }
        
        return c.Next()
    }
}
```

### Conditional Authorization
```go
func CanEditContent(rbacSvc *rbac.Service, userID, contentOwnerID xid.ID, roles []string) bool {
    return rbacSvc.AllowedWithRoles(&rbac.Context{
        Subject:  "user",
        Action:   "edit",
        Resource: "content",
        Vars: map[string]string{
            "owner": fmt.Sprintf("%v", userID == contentOwnerID),
        },
    }, roles)
}
```

## Error Handling

Common errors:
- `role name cannot be empty` - Empty role name in registration
- `role %s not found` - Referenced role doesn't exist
- `circular role inheritance detected: %s` - Inheritance cycle
- `role %s not registered` - Attempting to assign unknown role
- `role %s is a platform role and can only be assigned in the platform organization`
- `role repository not initialized` - Service created without repositories
- `cannot update template roles through this method` - Attempting to modify template
- `cannot delete template roles through this method` - Attempting to delete template

## Testing

```go
func TestRoleRegistry_RegisterRole(t *testing.T) {
    registry := rbac.NewRoleRegistry()
    
    // Register initial role
    err := registry.RegisterRole(&rbac.RoleDefinition{
        Name:        "editor",
        Description: "Content editor",
        Permissions: []string{"edit on content"},
        Priority:    50,
    })
    require.NoError(t, err)
    
    // Override with additional permissions
    err = registry.RegisterRole(&rbac.RoleDefinition{
        Name:        "editor",
        Permissions: []string{"delete on content"},
    })
    require.NoError(t, err)
    
    // Verify merged permissions
    role, exists := registry.GetRole("editor")
    require.True(t, exists)
    assert.Contains(t, role.Permissions, "edit on content")
    assert.Contains(t, role.Permissions, "delete on content")
}

func TestRoleInheritance(t *testing.T) {
    registry := rbac.NewRoleRegistry()
    
    // Register parent
    registry.RegisterRole(&rbac.RoleDefinition{
        Name:        "member",
        Permissions: []string{"view on dashboard"},
        Priority:    40,
    })
    
    // Register child with inheritance
    registry.RegisterRole(&rbac.RoleDefinition{
        Name:         "admin",
        InheritsFrom: "member",
        Permissions:  []string{"manage on users"},
        Priority:     60,
    })
    
    // Bootstrap resolves inheritance
    err := registry.Bootstrap(ctx, db, nil, platformOrgID)
    require.NoError(t, err)
    
    // Admin should have both permissions
    // (verified via database or policy engine)
}

func TestPolicyEvaluation(t *testing.T) {
    svc := rbac.NewService()
    
    // Add policy
    svc.AddPolicy(&rbac.Policy{
        Subject:  "role:admin",
        Actions:  []string{"read", "write"},
        Resource: "users",
    })
    
    // Test allowed
    allowed := svc.AllowedWithRoles(&rbac.Context{
        Subject:  "user:123",
        Action:   "read",
        Resource: "users",
    }, []string{"admin"})
    assert.True(t, allowed)
    
    // Test denied
    allowed = svc.AllowedWithRoles(&rbac.Context{
        Subject:  "user:123",
        Action:   "delete",
        Resource: "users",
    }, []string{"admin"})
    assert.False(t, allowed)
}
```

## Performance Considerations

- Policy evaluation is O(n) where n = number of policies
- Role inheritance resolved once during Bootstrap
- Permission strings compared with simple case-insensitive equality
- Wildcard resources (`*`, `resource:*`) checked efficiently
- RoleRegistry uses map for O(1) role lookup
- Bootstrap runs once at startup, not per-request

## Security Considerations

- Default deny: `Allowed()` returns false if no policy matches
- Platform roles restricted to platform organization
- Template roles cannot be modified/deleted via org methods
- Inheritance cycles detected and rejected
- Condition variables must be explicitly provided
- Policy expressions validated during parse, not evaluation

## Configuration Example

```yaml
auth:
  rbac:
    enableCaching: true
    cacheTTL: "5m"
    defaultDeny: true
    auditChanges: true
    
    # Custom roles can be defined in config
    customRoles:
      - name: "content_moderator"
        description: "Moderates user content"
        inheritsFrom: "member"
        priority: 45
        permissions:
          - "view,edit,delete on content"
          - "view on reports"
```

## Bootstrap Flow

```
Server Startup
     │
     ▼
AuthSome.Init()
     │
     ├── Create RoleRegistry
     │
     ├── RegisterDefaultPlatformRoles()
     │   └── Creates: superadmin, owner, admin, member
     │
     ├── Plugin.Init() (for each plugin)
     │   └── Plugin calls registry.RegisterRole()
     │       (extends/overrides default roles)
     │
     ├── Database Migrations
     │
     └── RoleRegistry.Bootstrap()
         │
         ├── resolveInheritance()
         │   └── Flattens inheritance chains
         │
         ├── upsertPermission() (for each unique permission)
         │   └── Creates permission records in DB
         │
         ├── upsertRole() (for each role)
         │   └── Creates/updates role records in DB
         │
         └── rbacService.AddExpression() (for each role/permission combo)
             └── Adds policies to policy engine
```
