---
title: Overview
description: Extend AuthSome Go with powerful authentication plugins for various use cases
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

AuthSome Go features a powerful plugin system that allows you to extend authentication functionality with various methods and features. Plugins are organized into three categories based on complexity and use cases.

## Plugin Categories

<Cards>
  <Card
    title="ðŸ”§ Core Plugins"
    description="Essential authentication methods for most applications"
    href="/docs/go/plugins/core"
  />
  <Card
    title="âš¡ Advanced Plugins"
    description="Enhanced security and user experience features"
    href="/docs/go/plugins/advanced"
  />
  <Card
    title="ðŸ¢ Enterprise Plugins"
    description="Enterprise-grade features for large organizations"
    href="/docs/go/plugins/enterprise"
  />
</Cards>

## Plugin Architecture

AuthSome Go plugins follow a consistent architecture pattern that makes them easy to develop, configure, and integrate:

```go
// Plugin interface that all plugins must implement
type Plugin interface {
    ID() string                                    // Unique plugin identifier
    Init(auth *authsome.Auth) error               // Initialize plugin with dependencies
    RegisterRoutes(router forge.Router) error     // Register HTTP routes
    RegisterHooks(hooks *HookRegistry) error      // Register lifecycle hooks
    Migrate() error                               // Run database migrations
}

// Example plugin implementation
type EmailPasswordPlugin struct {
    service *emailpassword.Service
    config  emailpassword.Config
}

func NewEmailPasswordPlugin() *EmailPasswordPlugin {
    return &EmailPasswordPlugin{}
}

func (p *EmailPasswordPlugin) ID() string {
    return "email-password"
}

func (p *EmailPasswordPlugin) Init(auth *authsome.Auth) error {
    // Initialize service with dependencies from auth instance
    var config emailpassword.Config
    if err := auth.Config().Bind("auth.plugins.emailPassword", &config); err != nil {
        return fmt.Errorf("failed to bind config: %w", err)
    }
    
    p.config = config
    p.service = emailpassword.NewService(
        auth.Config(),
        auth.UserRepository(),
        auth.SessionService(),
        auth.PasswordHasher(),
    )
    
    return nil
}

func (p *EmailPasswordPlugin) RegisterRoutes(router forge.Router) error {
    handler := emailpassword.NewHandler(p.service)
    
    router.POST("/auth/signup", handler.SignUp)
    router.POST("/auth/signin", handler.SignIn)
    router.POST("/auth/password/reset", handler.RequestPasswordReset)
    router.POST("/auth/password/reset/confirm", handler.ConfirmPasswordReset)
    
    return nil
}

func (p *EmailPasswordPlugin) RegisterHooks(hooks *HookRegistry) error {
    // Register before/after hooks for plugin events
    hooks.Register("before:signup", p.beforeSignUp)
    hooks.Register("after:signup", p.afterSignUp)
    hooks.Register("before:signin", p.beforeSignIn)
    hooks.Register("after:signin", p.afterSignIn)
    
    return nil
}

func (p *EmailPasswordPlugin) Migrate() error {
    // Plugin-specific database migrations
    return p.service.Migrate()
}
```

## Plugin Configuration

Plugins are configured through the main AuthSome configuration system with plugin-specific sections:

<Tabs items={['YAML Configuration', 'Environment Variables', 'Programmatic']}>
  <Tab value="YAML Configuration">
    ```yaml
    auth:
      plugins:
        # Core plugins
        emailPassword:
          enabled: true
          requireEmailVerification: true
          passwordPolicy:
            minLength: 8
            requireUpper: true
            requireLower: true
            requireNumbers: true
            requireSymbols: false
        
        twoFactor:
          enabled: true
          issuer: "MyApp"
          methods: ["totp", "sms"]
          backupCodes: true
        
        # Advanced plugins
        oauth:
          enabled: true
          providers:
            google:
              clientId: "${GOOGLE_CLIENT_ID}"
              clientSecret: "${GOOGLE_CLIENT_SECRET}"
              scopes: ["email", "profile"]
            github:
              clientId: "${GITHUB_CLIENT_ID}"
              clientSecret: "${GITHUB_CLIENT_SECRET}"
        
        magicLink:
          enabled: true
          tokenExpiry: "15m"
          maxAttempts: 3
        
        # Enterprise plugins
        saml:
          enabled: true
          providers:
            okta:
              entityId: "https://myapp.com"
              ssoUrl: "https://mycompany.okta.com/app/myapp/sso/saml"
              certificate: "${OKTA_CERTIFICATE}"
        
        rbac:
          enabled: true
          defaultRole: "user"
          superAdminRole: "admin"
    ```
  </Tab>
  <Tab value="Environment Variables">
    ```bash
    # Core plugins
    AUTH_PLUGINS_EMAIL_PASSWORD_ENABLED=true
    AUTH_PLUGINS_EMAIL_PASSWORD_REQUIRE_EMAIL_VERIFICATION=true
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_POLICY_MIN_LENGTH=8

    # Two-factor authentication
    AUTH_PLUGINS_TWO_FACTOR_ENABLED=true
    AUTH_PLUGINS_TWO_FACTOR_ISSUER=MyApp
    AUTH_PLUGINS_TWO_FACTOR_METHODS=totp,sms

    # OAuth
    AUTH_PLUGINS_OAUTH_ENABLED=true
    AUTH_PLUGINS_OAUTH_PROVIDERS_GOOGLE_CLIENT_ID=your_google_client_id
    AUTH_PLUGINS_OAUTH_PROVIDERS_GOOGLE_CLIENT_SECRET=your_google_client_secret

    # Magic Link
    AUTH_PLUGINS_MAGIC_LINK_ENABLED=true
    AUTH_PLUGINS_MAGIC_LINK_TOKEN_EXPIRY=15m

    # RBAC
    AUTH_PLUGINS_RBAC_ENABLED=true
    AUTH_PLUGINS_RBAC_DEFAULT_ROLE=user
    ```
  </Tab>
  <Tab value="Programmatic">
    ```go
    config := authsome.Config{
        Plugins: authsome.PluginConfigs{
            EmailPassword: &emailpassword.Config{
                Enabled:                  true,
                RequireEmailVerification: true,
                PasswordPolicy: emailpassword.PasswordPolicy{
                    MinLength:      8,
                    RequireUpper:   true,
                    RequireLower:   true,
                    RequireNumbers: true,
                    RequireSymbols: false,
                },
            },
            TwoFactor: &twofactor.Config{
                Enabled:     true,
                Issuer:      "MyApp",
                Methods:     []string{"totp", "sms"},
                BackupCodes: true,
            },
            OAuth: &oauth.Config{
                Enabled: true,
                Providers: map[string]oauth.ProviderConfig{
                    "google": {
                        ClientID:     os.Getenv("GOOGLE_CLIENT_ID"),
                        ClientSecret: os.Getenv("GOOGLE_CLIENT_SECRET"),
                        Scopes:       []string{"email", "profile"},
                    },
                },
            },
            RBAC: &rbac.Config{
                Enabled:        true,
                DefaultRole:    "user",
                SuperAdminRole: "admin",
            },
        },
    }

    auth, err := authsome.New(config)
    if err != nil {
        log.Fatal(err)
    }
    ```
  </Tab>
</Tabs>

## Plugin Registration

Register plugins with your AuthSome instance:

```go
func main() {
    // Create AuthSome instance
    auth, err := authsome.New(config)
    if err != nil {
        log.Fatal(err)
    }

    // Register core plugins
    auth.RegisterPlugin(emailpassword.NewPlugin())
    auth.RegisterPlugin(twofactor.NewPlugin())
    auth.RegisterPlugin(username.NewPlugin())

    // Register advanced plugins
    auth.RegisterPlugin(oauth.NewPlugin())
    auth.RegisterPlugin(magiclink.NewPlugin())
    auth.RegisterPlugin(passkey.NewPlugin())

    // Register enterprise plugins
    auth.RegisterPlugin(saml.NewPlugin())
    auth.RegisterPlugin(oidc.NewPlugin())
    auth.RegisterPlugin(rbac.NewPlugin())

    // Initialize all plugins
    if err := auth.InitializePlugins(); err != nil {
        log.Fatal(err)
    }

    // Mount to Forge app
    app := forge.New()
    auth.Mount(app, "/auth")

    app.Listen(":8080")
}
```

## Plugin Hooks

Plugins can register hooks to extend functionality at various points in the authentication flow:

```go
type HookRegistry struct {
    hooks map[string][]HookFunc
}

type HookFunc func(ctx context.Context, data interface{}) error

// Available hook points
const (
    // User lifecycle
    BeforeUserCreate = "before:user:create"
    AfterUserCreate  = "after:user:create"
    BeforeUserUpdate = "before:user:update"
    AfterUserUpdate  = "after:user:update"
    BeforeUserDelete = "before:user:delete"
    AfterUserDelete  = "after:user:delete"

    // Authentication
    BeforeSignUp = "before:signup"
    AfterSignUp  = "after:signup"
    BeforeSignIn = "before:signin"
    AfterSignIn  = "after:signin"
    BeforeSignOut = "before:signout"
    AfterSignOut  = "after:signout"

    // Session management
    BeforeSessionCreate = "before:session:create"
    AfterSessionCreate  = "after:session:create"
    BeforeSessionRevoke = "before:session:revoke"
    AfterSessionRevoke  = "after:session:revoke"

    // Password management
    BeforePasswordChange = "before:password:change"
    AfterPasswordChange  = "after:password:change"
    BeforePasswordReset  = "before:password:reset"
    AfterPasswordReset   = "after:password:reset"
)

// Example hook implementation
func (p *EmailPasswordPlugin) afterSignUp(ctx context.Context, data interface{}) error {
    signUpData := data.(*SignUpData)
    
    // Send welcome email
    if err := p.emailService.SendWelcomeEmail(ctx, signUpData.User); err != nil {
        log.Printf("Failed to send welcome email: %v", err)
        // Don't fail the signup process for email errors
    }
    
    // Log audit event
    p.auditService.LogEvent(ctx, &AuditEvent{
        Action:     "user_signup",
        Resource:   "user",
        ResourceID: signUpData.User.ID,
        Success:    true,
        Metadata: map[string]interface{}{
            "method": "email_password",
            "email":  signUpData.User.Email,
        },
    })
    
    return nil
}
```

## Plugin Development

Create custom plugins by implementing the Plugin interface:

```go
package myplugin

import (
    "github.com/xraph/authsome"
    "github.com/xraph/forge"
)

type MyCustomPlugin struct {
    config MyPluginConfig
    service *MyPluginService
}

type MyPluginConfig struct {
    Enabled bool   `json:"enabled"`
    APIKey  string `json:"apiKey"`
    Timeout int    `json:"timeout"`
}

func NewPlugin() *MyCustomPlugin {
    return &MyCustomPlugin{}
}

func (p *MyCustomPlugin) ID() string {
    return "my-custom-plugin"
}

func (p *MyCustomPlugin) Init(auth *authsome.Auth) error {
    // Bind configuration
    if err := auth.Config().Bind("auth.plugins.myCustomPlugin", &p.config); err != nil {
        return err
    }

    // Initialize service with dependencies
    p.service = NewMyPluginService(
        p.config,
        auth.UserRepository(),
        auth.SessionService(),
    )

    return nil
}

func (p *MyCustomPlugin) RegisterRoutes(router forge.Router) error {
    handler := NewMyPluginHandler(p.service)
    
    router.POST("/auth/my-custom/action", handler.CustomAction)
    router.GET("/auth/my-custom/status", handler.GetStatus)
    
    return nil
}

func (p *MyCustomPlugin) RegisterHooks(hooks *HookRegistry) error {
    hooks.Register(AfterSignIn, p.onSignIn)
    return nil
}

func (p *MyCustomPlugin) Migrate() error {
    // Run any database migrations needed by this plugin
    return p.service.Migrate()
}

func (p *MyCustomPlugin) onSignIn(ctx context.Context, data interface{}) error {
    // Custom logic after user signs in
    return nil
}
```

<Callout type="info">
**Plugin Best Practices**: Always handle errors gracefully, use proper configuration binding, implement comprehensive logging, and follow the established patterns for consistency.
</Callout>

## Available Plugins

### Core Plugins
Essential authentication methods that most applications need:

- **Email & Password** - Traditional email/password authentication
- **Two-Factor Authentication** - TOTP, SMS, and backup codes
- **Username Authentication** - Username-based login alternative
- **Anonymous Authentication** - Guest user sessions

### Advanced Plugins
Enhanced features for better security and user experience:

- **OAuth Providers** - Google, GitHub, Facebook, and more
- **Magic Link** - Passwordless email-based authentication
- **Phone Authentication** - SMS-based verification
- **Passkey/WebAuthn** - Modern biometric authentication
- **RBAC** - Role-based access control
- **Audit Logging** - Comprehensive audit trails

### Enterprise Plugins
Enterprise-grade features for large organizations:

- **SAML SSO** - Enterprise single sign-on
- **OIDC Provider** - OpenID Connect identity provider
- **Multi-Session** - Multiple concurrent sessions
- **Admin Panel** - Administrative interface
- **Advanced Security** - Enhanced security features
- **Compliance** - GDPR, SOC2, and other compliance tools

## Next Steps

<Cards>
  <Card
    title="Core Plugins"
    description="Start with essential authentication methods"
    href="/docs/go/plugins/core"
  />
  <Card
    title="Advanced Plugins"
    description="Add enhanced security and UX features"
    href="/docs/go/plugins/advanced"
  />
  <Card
    title="Enterprise Plugins"
    description="Implement enterprise-grade features"
    href="/docs/go/plugins/enterprise"
  />
  <Card
    title="Plugin Development"
    description="Learn to create custom plugins"
    href="/docs/go/guides/plugin-development"
  />
</Cards>