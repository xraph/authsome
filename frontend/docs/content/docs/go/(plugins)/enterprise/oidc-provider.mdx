---
title: OIDC Provider
description: Turn AuthSome into a full OpenID Connect Provider for authenticating users across multiple applications
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

# OIDC Provider

Transform AuthSome into a complete OpenID Connect (OIDC) Provider, allowing you to use it as a centralized identity provider for all your applications.

<Callout type="info">
This plugin turns AuthSome into an **Identity Provider** that other applications can use for authentication, similar to Okta, Auth0, or Keycloak.
</Callout>

## Features

- ✅ **OpenID Connect 1.0** compliant
- ✅ **Authorization Code Flow** with PKCE
- ✅ **Client Credentials Flow** for machine-to-machine
- ✅ **ID Tokens & Access Tokens** with JWT
- ✅ **UserInfo Endpoint** for profile data
- ✅ **Dynamic Client Registration**
- ✅ **JWKS Endpoint** for token verification
- ✅ **Discovery Endpoint** (.well-known/openid-configuration)
- ✅ **Refresh Tokens** for long-lived access
- ✅ **Scope-based Access Control**

## Quick Start

### Installation

```go
import (
    "github.com/xraph/authsome"
    "github.com/xraph/authsome/plugins/oidcprovider"
)

auth := authsome.New(
    authsome.WithDatabase(db),
    authsome.WithPlugins(
        oidcprovider.NewPlugin(),
    ),
)
```

### Configuration

```yaml
plugins:
  oidc_provider:
    enabled: true
    issuer: "https://auth.yourdomain.com"
    
    # Token configuration
    tokens:
      id_token_lifetime: 3600      # 1 hour
      access_token_lifetime: 3600  # 1 hour
      refresh_token_lifetime: 2592000  # 30 days
      
    # Supported scopes
    scopes:
      - openid
      - profile
      - email
      - offline_access
      
    # Signing keys
    keys:
      algorithm: "RS256"
      key_path: "/path/to/private-key.pem"
      key_id: "key-2024-01"
```

## Registering OAuth Clients

### Via CLI

```bash
authsome-cli oidc register-client \
  --name "My Application" \
  --redirect-uris "https://myapp.com/callback,https://myapp.com/silent-renew" \
  --post-logout-redirect-uris "https://myapp.com/" \
  --scopes "openid,profile,email" \
  --grant-types "authorization_code,refresh_token"
```

### Via API

```bash
curl -X POST https://auth.yourdomain.com/api/auth/oidc/clients \
  -H "Authorization: Bearer ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "client_name": "My Application",
    "redirect_uris": [
      "https://myapp.com/callback"
    ],
    "post_logout_redirect_uris": [
      "https://myapp.com/"
    ],
    "grant_types": [
      "authorization_code",
      "refresh_token"
    ],
    "response_types": [
      "code"
    ],
    "scopes": [
      "openid",
      "profile",
      "email"
    ]
  }'
```

## Client Integration

### Authorization Code Flow

<Tabs items={['JavaScript', 'Go', 'Python']}>
<Tab value="JavaScript">
```javascript
// Using oidc-client-ts
import { UserManager } from 'oidc-client-ts';

const userManager = new UserManager({
    authority: 'https://auth.yourdomain.com',
    client_id: 'your-client-id',
    redirect_uri: 'https://myapp.com/callback',
    response_type: 'code',
    scope: 'openid profile email',
    post_logout_redirect_uri: 'https://myapp.com/',
});

// Sign in
await userManager.signinRedirect();

// Handle callback
const user = await userManager.signinRedirectCallback();
console.log('Access Token:', user.access_token);
console.log('ID Token:', user.id_token);
console.log('User Profile:', user.profile);
```
</Tab>

<Tab value="Go">
```go
import (
    "github.com/coreos/go-oidc/v3/oidc"
    "golang.org/x/oauth2"
)

// Configure OAuth2
config := oauth2.Config{
    ClientID:     "your-client-id",
    ClientSecret: "your-client-secret",
    RedirectURL:  "https://myapp.com/callback",
    Endpoint: oauth2.Endpoint{
        AuthURL:  "https://auth.yourdomain.com/api/auth/oidc/authorize",
        TokenURL: "https://auth.yourdomain.com/api/auth/oidc/token",
    },
    Scopes: []string{oidc.ScopeOpenID, "profile", "email"},
}

// Redirect to login
http.Redirect(w, r, config.AuthCodeURL(state), http.StatusFound)

// Handle callback
token, err := config.Exchange(ctx, code)
idToken, err := verifier.Verify(ctx, token.Extra("id_token").(string))
```
</Tab>

<Tab value="Python">
```python
from authlib.integrations.requests_client import OAuth2Session

client = OAuth2Session(
    client_id='your-client-id',
    client_secret='your-client-secret',
    redirect_uri='https://myapp.com/callback',
    scope='openid profile email'
)

# Get authorization URL
authorization_url, state = client.create_authorization_url(
    'https://auth.yourdomain.com/api/auth/oidc/authorize'
)

# Exchange code for token
token = client.fetch_token(
    'https://auth.yourdomain.com/api/auth/oidc/token',
    authorization_response=request.url
)

# Get user info
userinfo = client.get(
    'https://auth.yourdomain.com/api/auth/oidc/userinfo'
).json()
```
</Tab>
</Tabs>

## Discovery Endpoint

AuthSome automatically exposes OIDC discovery metadata:

```bash
curl https://auth.yourdomain.com/.well-known/openid-configuration
```

Response includes:
- Authorization endpoint
- Token endpoint  
- UserInfo endpoint
- JWKS URI
- Supported scopes, grant types, response types
- Signing algorithms

## Token Verification

### JWKS Endpoint

Public keys for token verification:

```bash
curl https://auth.yourdomain.com/api/auth/oidc/.well-known/jwks.json
```

### Verify ID Token

<Tabs items={['Node.js', 'Go', 'Python']}>
<Tab value="Node.js">
```javascript
import { createRemoteJWKSet, jwtVerify } from 'jose';

const JWKS = createRemoteJWKSet(
    new URL('https://auth.yourdomain.com/api/auth/oidc/.well-known/jwks.json')
);

const { payload } = await jwtVerify(idToken, JWKS, {
    issuer: 'https://auth.yourdomain.com',
    audience: 'your-client-id',
});

console.log('User ID:', payload.sub);
console.log('Email:', payload.email);
```
</Tab>

<Tab value="Go">
```go
import "github.com/coreos/go-oidc/v3/oidc"

provider, err := oidc.NewProvider(ctx, "https://auth.yourdomain.com")
verifier := provider.Verifier(&oidc.Config{ClientID: "your-client-id"})

idToken, err := verifier.Verify(ctx, rawIDToken)
var claims struct {
    Email string `json:"email"`
    Name  string `json:"name"`
}
idToken.Claims(&claims)
```
</Tab>

<Tab value="Python">
```python
from authlib.jose import jwt

# Fetch JWKS
jwks = requests.get(
    'https://auth.yourdomain.com/api/auth/oidc/.well-known/jwks.json'
).json()

# Verify token
claims = jwt.decode(id_token, jwks)
claims.validate()

print('User ID:', claims['sub'])
print('Email:', claims['email'])
```
</Tab>
</Tabs>

## Scopes and Claims

### Standard Scopes

- `openid` - Required, returns `sub` claim
- `profile` - Returns `name`, `picture`, `updated_at`
- `email` - Returns `email`, `email_verified`
- `offline_access` - Returns refresh token

### Custom Scopes

```yaml
plugins:
  oidc_provider:
    custom_scopes:
      company:
        claims:
          - department
          - employee_id
          - manager
      roles:
        claims:
          - roles
          - permissions
```

## Client Credentials Flow

For machine-to-machine authentication:

```bash
curl -X POST https://auth.yourdomain.com/api/auth/oidc/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret" \
  -d "scope=api:read api:write"
```

## Refresh Tokens

```bash
curl -X POST https://auth.yourdomain.com/api/auth/oidc/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=REFRESH_TOKEN" \
  -d "client_id=your-client-id" \
  -d "client_secret=your-client-secret"
```

## API Reference

### Endpoints

- `GET /.well-known/openid-configuration` - Discovery
- `GET /api/auth/oidc/authorize` - Authorization
- `POST /api/auth/oidc/token` - Token exchange
- `GET /api/auth/oidc/userinfo` - User profile
- `GET /api/auth/oidc/.well-known/jwks.json` - Public keys
- `POST /api/auth/oidc/clients` - Register client
- `GET /api/auth/oidc/clients` - List clients
- `GET /api/auth/oidc/logout` - End session

### Grant Types

- `authorization_code` - Standard web app flow
- `refresh_token` - Token refresh
- `client_credentials` - Machine-to-machine

### Response Types

- `code` - Authorization code (most secure)
- `id_token` - Implicit flow (not recommended)
- `id_token token` - Implicit flow with access token

## Resources

- [OpenID Connect Specification](https://openid.net/specs/openid-connect-core-1_0.html)
- [OIDC Provider README](https://github.com/xraph/authsome/blob/main/plugins/oidcprovider/README.md)
- [OAuth 2.0 RFC](https://tools.ietf.org/html/rfc6749)

<Callout type="warning">
Always use HTTPS in production and keep client secrets secure. Never expose client secrets in frontend code.
</Callout>

