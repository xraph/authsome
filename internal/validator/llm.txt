# Validator Utilities

## Package Purpose

Provides input validation functions for emails, passwords, usernames, and other user inputs used throughout AuthSome.

## Key Files

- **email.go**: Email format validation
- **email_test.go**: Email validation tests
- **password.go**: Password strength validation
- **password_test.go**: Password validation tests

## Public API

### Email Validation

#### Validate Email Format
```go
valid := validator.IsValidEmail("user@example.com")
// Returns true if email format is valid
```

Implementation uses regex pattern matching:
- Local part: alphanumeric, dots, hyphens, underscores
- Domain: valid domain format
- TLD: at least 2 characters

### Password Validation

#### Password Requirements
```go
type PasswordRequirements struct {
    MinLength      int  // Minimum password length
    MaxLength      int  // Maximum password length
    RequireUpper   bool // Require uppercase letter
    RequireLower   bool // Require lowercase letter
    RequireDigit   bool // Require digit
    RequireSpecial bool // Require special character
}
```

#### Validate Password
```go
requirements := validator.PasswordRequirements{
    MinLength:      8,
    RequireUpper:   true,
    RequireLower:   true,
    RequireDigit:   true,
    RequireSpecial: true,
}

err := validator.ValidatePassword("MyPass123!", requirements)
if err != nil {
    // Password doesn't meet requirements
    // err.Error() contains specific reason
}
```

#### Default Requirements
```go
// Get sensible default password requirements
requirements := validator.DefaultPasswordRequirements()
// MinLength: 8
// MaxLength: 128
// RequireUpper: true
// RequireLower: true
// RequireDigit: true
// RequireSpecial: false
```

### Username Validation (if implemented)

```go
valid := validator.IsValidUsername(username)
// Validates username format (alphanumeric, underscores, hyphens)
```

## Validation Rules

### Email
- Format: `local@domain.tld`
- Local part: 1-64 characters
- Domain: Valid domain format
- TLD: 2+ characters
- Special characters: dots, hyphens, underscores in local part
- No consecutive dots
- No leading/trailing dots

### Password
- **Length**: Configurable min/max (default: 8-128)
- **Uppercase**: A-Z (if required)
- **Lowercase**: a-z (if required)
- **Digits**: 0-9 (if required)
- **Special**: !@#$%^&*()_+-=[]{}|;:,.<>? (if required)

### Username (if implemented)
- Length: 3-30 characters
- Characters: a-z, A-Z, 0-9, underscore, hyphen
- No leading/trailing special characters
- No consecutive special characters

## Error Messages

Password validation returns descriptive errors:
- "password too short (minimum 8 characters)"
- "password too long (maximum 128 characters)"
- "password must contain uppercase letter"
- "password must contain lowercase letter"
- "password must contain digit"
- "password must contain special character"

## Common Usage Patterns

### Service-Level Validation
```go
func (s *UserService) Create(ctx context.Context, req *CreateUserRequest) (*User, error) {
    // Validate email
    if !validator.IsValidEmail(req.Email) {
        return nil, errs.InvalidInput("email", "invalid format")
    }
    
    // Validate password
    if err := validator.ValidatePassword(req.Password, s.config.PasswordRequirements); err != nil {
        return nil, errs.WeakPassword(err.Error())
    }
    
    // Continue with user creation...
}
```

### Handler-Level Validation
```go
func (h *Handler) SignUp(c *forge.Context) error {
    var req SignUpRequest
    if err := c.BindJSON(&req); err != nil {
        return c.JSON(400, ErrorResponse{Message: "invalid request"})
    }
    
    // Validate email
    if !validator.IsValidEmail(req.Email) {
        return c.JSON(400, ErrorResponse{
            Message: "Invalid email format",
            Field:   "email",
        })
    }
    
    // Continue...
}
```

## Testing

```go
func TestIsValidEmail(t *testing.T) {
    tests := []struct {
        email string
        valid bool
    }{
        {"user@example.com", true},
        {"user.name@example.co.uk", true},
        {"user+tag@example.com", true},
        {"invalid.email", false},
        {"@example.com", false},
        {"user@", false},
    }
    
    for _, tt := range tests {
        result := validator.IsValidEmail(tt.email)
        assert.Equal(t, tt.valid, result, "email: %s", tt.email)
    }
}
```

## Performance

- Email validation: <1μs (regex match)
- Password validation: <1μs (string checks)
- Validators are stateless (no memory allocation)

## Configuration Example

```yaml
auth:
  user:
    passwordRequirements:
      minLength: 12
      maxLength: 128
      requireUpper: true
      requireLower: true
      requireDigit: true
      requireSpecial: true
```

## Best Practices

1. **Validate Early**: Validate at the earliest point (handler or service entry)
2. **Clear Errors**: Provide specific error messages
3. **Consistent Rules**: Use same requirements across application
4. **User Feedback**: Show requirements before submission
5. **Locale Support**: Consider i18n for error messages

## Security Considerations

- Validation prevents injection attacks
- Email validation prevents spoofing
- Password requirements enforce minimum security
- Validation does not guarantee safety (always sanitize data)

## Future Enhancements

- Disposable email detection
- Common password blacklist
- Password pwned check (haveibeenpwned.com)
- Unicode email support
- Phone number validation
- URL validation
- Credit card validation

