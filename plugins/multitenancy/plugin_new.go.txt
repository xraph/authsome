package multitenancy

import (
	"context"
	"fmt"

	"github.com/rs/xid"
	"github.com/uptrace/bun"
	"github.com/xraph/authsome/core/hooks"
	"github.com/xraph/authsome/core/registry"
	"github.com/xraph/authsome/core/session"
	"github.com/xraph/authsome/core/user"
	"github.com/xraph/authsome/plugins/multitenancy/app"
	"github.com/xraph/authsome/plugins/multitenancy/config"
	"github.com/xraph/authsome/plugins/multitenancy/decorators"
	"github.com/xraph/authsome/plugins/multitenancy/handlers"
	"github.com/xraph/authsome/plugins/multitenancy/repository"
	"github.com/xraph/forge"
)

// Plugin implements the multi-tenancy plugin
type Plugin struct {
	// Core services
	appService    *app.Service
	configService *config.Service

	// Handlers
	appHandler    *handlers.AppHandler
	memberHandler *handlers.MemberHandler
	teamHandler   *handlers.TeamHandler

	// Database
	db *bun.DB

	// Configuration
	config        Config
	defaultConfig Config

	// Logger
	logger forge.Logger
}

// Config holds the multi-tenancy plugin configuration
type Config struct {
	// PlatformAppID is the ID of the platform app
	PlatformAppID string `json:"platformAppId"`

	// DefaultAppName is the name of the default app in standalone mode
	DefaultAppName string `json:"defaultAppName"`

	// EnableAppCreation allows users to create new apps
	EnableAppCreation bool `json:"enableAppCreation"`

	// MaxMembersPerApp limits the number of members per app
	MaxMembersPerApp int `json:"maxMembersPerApp"`

	// MaxTeamsPerApp limits the number of teams per app
	MaxTeamsPerApp int `json:"maxTeamsPerApp"`

	// RequireInvitation requires invitation for joining apps
	RequireInvitation bool `json:"requireInvitation"`

	// InvitationExpiryHours sets how long invitations are valid
	InvitationExpiryHours int `json:"invitationExpiryHours"`
}

// PluginOption is a functional option for configuring the plugin
type PluginOption func(*Plugin)

// WithDefaultConfig sets the default configuration for the plugin
func WithDefaultConfig(cfg Config) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig = cfg
	}
}

// WithPlatformAppID sets the platform app ID
func WithPlatformAppID(id string) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.PlatformAppID = id
	}
}

// WithDefaultAppName sets the default app name
func WithDefaultAppName(name string) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.DefaultAppName = name
	}
}

// WithEnableAppCreation sets whether app creation is enabled
func WithEnableAppCreation(enabled bool) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.EnableAppCreation = enabled
	}
}

// WithMaxMembersPerApp sets the maximum members per app
func WithMaxMembersPerApp(max int) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.MaxMembersPerApp = max
	}
}

// WithMaxTeamsPerApp sets the maximum teams per app
func WithMaxTeamsPerApp(max int) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.MaxTeamsPerApp = max
	}
}

// WithRequireInvitation sets whether invitation is required
func WithRequireInvitation(required bool) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.RequireInvitation = required
	}
}

// WithInvitationExpiryHours sets the invitation expiry hours
func WithInvitationExpiryHours(hours int) PluginOption {
	return func(p *Plugin) {
		p.defaultConfig.InvitationExpiryHours = hours
	}
}

// NewPlugin creates a new multi-tenancy plugin instance with optional configuration
func NewPlugin(opts ...PluginOption) *Plugin {
	p := &Plugin{
		// Set built-in defaults
		defaultConfig: Config{
			DefaultAppName:        "Platform App",
			MaxMembersPerApp:      1000,
			MaxTeamsPerApp:        100,
			InvitationExpiryHours: 72,
		},
	}

	// Apply functional options
	for _, opt := range opts {
		opt(p)
	}

	return p
}

// ID returns the plugin identifier
func (p *Plugin) ID() string {
	return "multitenancy"
}

// Init initializes the plugin with dependencies
func (p *Plugin) Init(auth interface{}) error {
	// Type assert to get the auth instance
	authInstance, ok := auth.(interface {
		GetDB() *bun.DB
		GetForgeApp() forge.App
		GetServiceRegistry() *registry.ServiceRegistry
	})
	if !ok {
		return fmt.Errorf("invalid auth instance type")
	}

	p.db = authInstance.GetDB()
	forgeApp := authInstance.GetForgeApp()
	configManager := forgeApp.Config()
	serviceRegistry := authInstance.GetServiceRegistry()

	// Get logger from Forge app
	p.logger = forgeApp.Logger().With(forge.F("plugin", "multitenancy"))

	// Register models with Bun for relationships to work
	// Register TeamMember first as it's the join table for m2m relationships
	p.db.RegisterModel((*app.TeamMember)(nil))
	p.db.RegisterModel(
		(*app.App)(nil),
		(*app.Member)(nil),
		(*app.Team)(nil),
		(*app.Invitation)(nil),
	)

	// Try to bind plugin configuration using Forge ConfigManager with provided defaults
	if err := configManager.BindWithDefault("auth.multitenancy", &p.config, p.defaultConfig); err != nil {
		// Log but don't fail - use defaults
		p.logger.Warn("failed to bind multitenancy config", forge.F("error", err.Error()))
	}

	// Set default values
	if p.config.DefaultAppName == "" {
		p.config.DefaultAppName = "Default App"
	}
	if p.config.MaxMembersPerApp == 0 {
		p.config.MaxMembersPerApp = 100
	}
	if p.config.MaxTeamsPerApp == 0 {
		p.config.MaxTeamsPerApp = 10
	}
	if p.config.InvitationExpiryHours == 0 {
		p.config.InvitationExpiryHours = 72 // 3 days
	}

	// Create repositories
	appRepo := repository.NewAppRepository(p.db)
	memberRepo := repository.NewAppMemberRepository(p.db)
	teamRepo := repository.NewAppTeamRepository(p.db)
	invitationRepo := repository.NewAppInvitationRepository(p.db)

	// Create app service config
	appConfig := app.Config{
		PlatformAppID:         p.config.PlatformAppID,
		DefaultAppName:        p.config.DefaultAppName,
		EnableAppCreation:     p.config.EnableAppCreation,
		MaxMembersPerApp:      p.config.MaxMembersPerApp,
		MaxTeamsPerApp:        p.config.MaxTeamsPerApp,
		RequireInvitation:     p.config.RequireInvitation,
		InvitationExpiryHours: p.config.InvitationExpiryHours,
	}

	// Create services
	p.appService = app.NewService(appConfig, appRepo, memberRepo, teamRepo, invitationRepo)

	// Create config service for app-specific config management
	// This wraps Forge's ConfigManager to provide multi-tenant configuration
	p.configService = config.NewService(configManager)

	// Create handlers
	p.appHandler = handlers.NewAppHandler(p.appService)
	p.memberHandler = handlers.NewMemberHandler(p.appService)
	p.teamHandler = handlers.NewTeamHandler(p.appService)

	// Register services in the registry
	serviceRegistry.SetAppService(p.appService)
	serviceRegistry.SetConfigService(p.configService)

	return nil
}

// RegisterRoutes registers the plugin's HTTP routes
func (p *Plugin) RegisterRoutes(router forge.Router) error {
	// App management routes
	appGroup := router.Group("/apps")
	{
		appGroup.POST("", p.appHandler.CreateApp,
			forge.WithName("multitenancy.apps.create"),
			forge.WithSummary("Create app"),
			forge.WithDescription("Create a new app in multi-tenant mode"),
			forge.WithResponseSchema(200, "App created", app.App{}),
			forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Apps"),
			forge.WithValidation(true),
		)

		appGroup.GET("", p.appHandler.ListApps,
			forge.WithName("multitenancy.apps.list"),
			forge.WithSummary("List apps"),
			forge.WithDescription("List all apps the user has access to"),
			forge.WithResponseSchema(200, "Apps retrieved", AppsListResponse{}),
			forge.WithResponseSchema(500, "Internal server error", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Apps"),
		)

		appGroup.GET("/:appId", p.appHandler.GetApp,
			forge.WithName("multitenancy.apps.get"),
			forge.WithSummary("Get app"),
			forge.WithDescription("Retrieve a specific app by ID"),
			forge.WithResponseSchema(200, "App retrieved", app.App{}),
			forge.WithResponseSchema(404, "App not found", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Apps"),
		)

		appGroup.PUT("/:appId", p.appHandler.UpdateApp,
			forge.WithName("multitenancy.apps.update"),
			forge.WithSummary("Update app"),
			forge.WithDescription("Update app details (name, metadata, settings)"),
			forge.WithResponseSchema(200, "App updated", app.App{}),
			forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
			forge.WithResponseSchema(404, "App not found", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Apps"),
			forge.WithValidation(true),
		)

		appGroup.DELETE("/:appId", p.appHandler.DeleteApp,
			forge.WithName("multitenancy.apps.delete"),
			forge.WithSummary("Delete app"),
			forge.WithDescription("Delete an app and all associated data. This action is irreversible."),
			forge.WithResponseSchema(200, "App deleted", MultitenancyStatusResponse{}),
			forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
			forge.WithResponseSchema(404, "App not found", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Apps"),
		)

		// Member management
		memberGroup := appGroup.Group("/:appId/members")
		{
			memberGroup.GET("", p.memberHandler.ListMembers,
				forge.WithName("multitenancy.members.list"),
				forge.WithSummary("List app members"),
				forge.WithDescription("List all members of an app with their roles and status"),
				forge.WithResponseSchema(200, "Members retrieved", MembersListResponse{}),
				forge.WithResponseSchema(404, "App not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Members"),
			)

			memberGroup.POST("/invite", p.memberHandler.InviteMember,
				forge.WithName("multitenancy.members.invite"),
				forge.WithSummary("Invite member to app"),
				forge.WithDescription("Send an invitation to a user to join the app"),
				forge.WithResponseSchema(200, "Invitation sent", app.Invitation{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Members"),
				forge.WithValidation(true),
			)

			memberGroup.PUT("/:memberId", p.memberHandler.UpdateMember,
				forge.WithName("multitenancy.members.update"),
				forge.WithSummary("Update member"),
				forge.WithDescription("Update member role or status within the app"),
				forge.WithResponseSchema(200, "Member updated", app.Member{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Member not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Members"),
				forge.WithValidation(true),
			)

			memberGroup.DELETE("/:memberId", p.memberHandler.RemoveMember,
				forge.WithName("multitenancy.members.remove"),
				forge.WithSummary("Remove member"),
				forge.WithDescription("Remove a member from the app"),
				forge.WithResponseSchema(200, "Member removed", MultitenancyStatusResponse{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Member not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Members"),
			)
		}

		// Team management
		teamGroup := appGroup.Group("/:appId/teams")
		{
			teamGroup.GET("", p.teamHandler.ListTeams,
				forge.WithName("multitenancy.teams.list"),
				forge.WithSummary("List teams"),
				forge.WithDescription("List all teams within the app"),
				forge.WithResponseSchema(200, "Teams retrieved", TeamsListResponse{}),
				forge.WithResponseSchema(404, "App not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
			)

			teamGroup.POST("", p.teamHandler.CreateTeam,
				forge.WithName("multitenancy.teams.create"),
				forge.WithSummary("Create team"),
				forge.WithDescription("Create a new team within the app"),
				forge.WithResponseSchema(200, "Team created", app.Team{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
				forge.WithValidation(true),
			)

			teamGroup.GET("/:teamId", p.teamHandler.GetTeam,
				forge.WithName("multitenancy.teams.get"),
				forge.WithSummary("Get team"),
				forge.WithDescription("Retrieve a specific team by ID"),
				forge.WithResponseSchema(200, "Team retrieved", app.Team{}),
				forge.WithResponseSchema(404, "Team not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
			)

			teamGroup.PUT("/:teamId", p.teamHandler.UpdateTeam,
				forge.WithName("multitenancy.teams.update"),
				forge.WithSummary("Update team"),
				forge.WithDescription("Update team details (name, description, etc.)"),
				forge.WithResponseSchema(200, "Team updated", app.Team{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Team not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
				forge.WithValidation(true),
			)

			teamGroup.DELETE("/:teamId", p.teamHandler.DeleteTeam,
				forge.WithName("multitenancy.teams.delete"),
				forge.WithSummary("Delete team"),
				forge.WithDescription("Delete a team from the app"),
				forge.WithResponseSchema(200, "Team deleted", MultitenancyStatusResponse{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Team not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
			)

			teamGroup.POST("/:teamId/members", p.teamHandler.AddTeamMember,
				forge.WithName("multitenancy.teams.members.add"),
				forge.WithSummary("Add team member"),
				forge.WithDescription("Add a member to a team"),
				forge.WithResponseSchema(200, "Team member added", MultitenancyStatusResponse{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Team or member not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
				forge.WithValidation(true),
			)

			teamGroup.DELETE("/:teamId/members/:memberId", p.teamHandler.RemoveTeamMember,
				forge.WithName("multitenancy.teams.members.remove"),
				forge.WithSummary("Remove team member"),
				forge.WithDescription("Remove a member from a team"),
				forge.WithResponseSchema(200, "Team member removed", MultitenancyStatusResponse{}),
				forge.WithResponseSchema(400, "Invalid request", MultitenancyErrorResponse{}),
				forge.WithResponseSchema(404, "Team or member not found", MultitenancyErrorResponse{}),
				forge.WithTags("Multitenancy", "Apps", "Teams"),
			)
		}
	}

	// Invitation routes
	inviteGroup := router.Group("/invitations")
	{
		inviteGroup.GET("/:token", p.memberHandler.GetInvitation,
			forge.WithName("multitenancy.invitations.get"),
			forge.WithSummary("Get invitation"),
			forge.WithDescription("Retrieve invitation details by token"),
			forge.WithResponseSchema(200, "Invitation retrieved", app.Invitation{}),
			forge.WithResponseSchema(404, "Invitation not found or expired", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Invitations"),
		)

		inviteGroup.POST("/:token/accept", p.memberHandler.AcceptInvitation,
			forge.WithName("multitenancy.invitations.accept"),
			forge.WithSummary("Accept invitation"),
			forge.WithDescription("Accept an app invitation and become a member"),
			forge.WithResponseSchema(200, "Invitation accepted", MultitenancyStatusResponse{}),
			forge.WithResponseSchema(400, "Invalid or expired invitation", MultitenancyErrorResponse{}),
			forge.WithResponseSchema(404, "Invitation not found", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Invitations"),
		)

		inviteGroup.POST("/:token/decline", p.memberHandler.DeclineInvitation,
			forge.WithName("multitenancy.invitations.decline"),
			forge.WithSummary("Decline invitation"),
			forge.WithDescription("Decline an app invitation"),
			forge.WithResponseSchema(200, "Invitation declined", MultitenancyStatusResponse{}),
			forge.WithResponseSchema(404, "Invitation not found", MultitenancyErrorResponse{}),
			forge.WithTags("Multitenancy", "Invitations"),
		)
	}

	return nil
}

// DTOs for multitenancy routes

// MultitenancyErrorResponse represents an error response
type MultitenancyErrorResponse struct {
	Error string `json:"error" example:"Error message"`
}

// MultitenancyStatusResponse represents a status response
type MultitenancyStatusResponse struct {
	Status string `json:"status" example:"success"`
}

// AppsListResponse represents a list of apps
type AppsListResponse []app.App

// MembersListResponse represents a list of members
type MembersListResponse []app.Member

// TeamsListResponse represents a list of teams
type TeamsListResponse []app.Team

// RegisterHooks registers the plugin's hooks
func (p *Plugin) RegisterHooks(hooks *hooks.HookRegistry) error {
	// Register app-related hooks
	hooks.RegisterAfterUserCreate(p.handleUserCreated)
	hooks.RegisterAfterUserDelete(p.handleUserDeleted)
	hooks.RegisterAfterSessionCreate(p.handleSessionCreated)

	return nil
}

// RegisterServiceDecorators replaces core services with multi-tenant aware versions
func (p *Plugin) RegisterServiceDecorators(services *registry.ServiceRegistry) error {
	// Decorate user service with multi-tenancy support
	if userService := services.UserService(); userService != nil {
		decoratedUserService := decorators.NewMultiTenantUserService(userService, p.appService)
		services.ReplaceUserService(decoratedUserService)
	}

	// Decorate session service with multi-tenancy support
	if sessionService := services.SessionService(); sessionService != nil {
		decoratedSessionService := decorators.NewMultiTenantSessionService(sessionService, p.appService)
		services.ReplaceSessionService(decoratedSessionService)
	}

	// Decorate auth service with multi-tenancy support
	if authService := services.AuthService(); authService != nil {
		decoratedAuthService := decorators.NewMultiTenantAuthService(authService, p.appService)
		services.ReplaceAuthService(decoratedAuthService)
	}

	// TODO: Implement JWT, API Key, and Forms decorators when needed
	// These will follow the same pattern as above

	return nil
}

// Migrate runs the plugin's database migrations
func (p *Plugin) Migrate() error {
	ctx := context.Background()

	// Create app table
	if _, err := p.db.NewCreateTable().
		Model((*app.App)(nil)).
		IfNotExists().
		Exec(ctx); err != nil {
		return fmt.Errorf("failed to create apps table: %w", err)
	}

	// Create member table
	if _, err := p.db.NewCreateTable().
		Model((*app.Member)(nil)).
		IfNotExists().
		Exec(ctx); err != nil {
		return fmt.Errorf("failed to create members table: %w", err)
	}

	// Create team table
	if _, err := p.db.NewCreateTable().
		Model((*app.Team)(nil)).
		IfNotExists().
		Exec(ctx); err != nil {
		return fmt.Errorf("failed to create teams table: %w", err)
	}

	// Create team member table
	if _, err := p.db.NewCreateTable().
		Model((*app.TeamMember)(nil)).
		IfNotExists().
		Exec(ctx); err != nil {
		return fmt.Errorf("failed to create team_members table: %w", err)
	}

	// Create invitation table
	if _, err := p.db.NewCreateTable().
		Model((*app.Invitation)(nil)).
		IfNotExists().
		Exec(ctx); err != nil {
		return fmt.Errorf("failed to create invitations table: %w", err)
	}

	return nil
}

// Hook handlers

// handleUserCreated is called when a user is created
// This ensures app membership in both standalone and SaaS modes
func (p *Plugin) handleUserCreated(ctx context.Context, u *user.User) error {
	// Check if this is the first user (no apps exist yet)
	apps, err := p.appService.ListApps(ctx, 1, 0)
	if err != nil || len(apps) == 0 {
		// This is the FIRST user - create the platform app
		// In both standalone and SaaS modes, this becomes the foundational app
		p.logger.Info("creating platform app for first user", forge.F("email", u.Email))

		platformSlug := p.config.PlatformAppID
		if platformSlug == "" {
			platformSlug = "platform"
		}

		platformApp, err := p.appService.CreateApp(ctx, &app.CreateAppRequest{
			Name: "Platform App",
			Slug: platformSlug,
		}, u.ID)
		if err != nil {
			return fmt.Errorf("failed to create platform app: %w", err)
		}

		// Add first user as OWNER of platform app (not just member)
		_, err = p.appService.AddMember(ctx, platformApp.ID, u.ID, app.RoleOwner)
		if err != nil {
			return fmt.Errorf("failed to add first user as platform owner: %w", err)
		}

		p.logger.Info("platform app created",
			forge.F("name", platformApp.Name),
			forge.F("id", platformApp.ID.String()))
		p.logger.Info("first user is now platform owner",
			forge.F("email", u.Email),
			forge.F("role", string(app.RoleOwner)))
		return nil
	}

	// Not the first user - behavior depends on mode
	// Get the platform/default app
	platformApp, err := p.appService.GetAppBySlug(ctx, "platform")
	if err != nil {
		// Fallback to default app if platform not found
		platformApp, err = p.appService.GetDefaultApp(ctx)
		if err != nil {
			return fmt.Errorf("failed to get platform/default app: %w", err)
		}
	}

	// In standalone mode, add all users to the platform app
	// In SaaS mode, users will create/join their own apps
	// For now, we'll add them to platform app in both modes (can be refined later)
	_, err = p.appService.AddMember(ctx, platformApp.ID, u.ID, app.RoleMember)
	if err != nil {
		// Check if already a member
		if err.Error() != "user is already a member of this app" {
			return fmt.Errorf("failed to add user to platform app: %w", err)
		}
		p.logger.Info("user already member of platform app", forge.F("email", u.Email))
	} else {
		p.logger.Info("user added to platform app as member", forge.F("email", u.Email))
	}

	return nil
}

// handleUserDeleted is called when a user is deleted
func (p *Plugin) handleUserDeleted(ctx context.Context, userID xid.ID) error {
	// Remove user from all apps
	return p.appService.RemoveUserFromAllApps(ctx, userID)
}

// handleSessionCreated is called when a session is created
func (p *Plugin) handleSessionCreated(ctx context.Context, s *session.Session) error {
	// App context is handled by the session service decorator
	// This hook is mainly for logging/auditing purposes
	return nil
}
