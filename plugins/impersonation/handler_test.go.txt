package impersonation

import (
	"bytes"
	"context"
	"encoding/json"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
	_ "unsafe" // for go:linkname

	"github.com/rs/xid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/xraph/authsome/core/impersonation"
	"github.com/xraph/authsome/schema"
	authsometesting "github.com/xraph/authsome/testing"
	"github.com/xraph/forge"
	forgetesting "github.com/xraph/forge/testing"
)

// Link to the internal Session interface from forge
// This is necessary because forge.Context uses internal types
//
//go:linkname Session github.com/xraph/forge/internal/shared.Session
type Session interface{}

func newMockForgeContext(method, path string, body interface{}) *mockForgeContext {
	var bodyBytes []byte
	if body != nil {
		bodyBytes, _ = json.Marshal(body)
	}

	req := httptest.NewRequest(method, path, bytes.NewReader(bodyBytes))
	req.Header.Set("Content-Type", "application/json")

	mock := authsometesting.Mock{}
	ctx := mock.NewMockForgeContext(req)

	return &mockForgeContext{MockForgeContext: ctx}
}

// mockForgeContext wraps testing.MockForgeContext to get all required methods
type mockForgeContext struct {
	*authsometesting.MockForgeContext
}

// Add any missing methods that are not in the testing.MockForgeContext
func (c *mockForgeContext) Bind(v interface{}) error {
	if c.Request().Body == nil {
		return nil
	}
	defer c.Request().Body.Close()
	return json.NewDecoder(c.Request().Body).Decode(v)
}

func (c *mockForgeContext) BindRequest(v interface{}) error {
	return c.Bind(v)
}

func (c *mockForgeContext) BindXML(v interface{}) error {
	return c.Bind(v)
}

func (c *mockForgeContext) Header(key string) string {
	return c.Request().Header.Get(key)
}

func (c *mockForgeContext) Bytes(status int, b []byte) error {
	_, err := c.Response().Write(b)
	return err
}

func (c *mockForgeContext) NoContent(status int) error {
	return nil
}

func (c *mockForgeContext) SetParam(name, value string) {
	// Store in a local map if needed - for now just no-op
}

func (c *mockForgeContext) Param(name string) string {
	// Return empty for now - tests don't really use this
	return ""
}

func (c *mockForgeContext) Params() map[string]string {
	return make(map[string]string)
}

func (c *mockForgeContext) ParamInt(name string) (int, error) {
	return 0, nil
}

func (c *mockForgeContext) ParamInt64(name string) (int64, error) {
	return 0, nil
}

func (c *mockForgeContext) ParamFloat64(name string) (float64, error) {
	return 0.0, nil
}

func (c *mockForgeContext) ParamBool(name string) (bool, error) {
	return false, nil
}

func (c *mockForgeContext) ParamIntDefault(name string, defaultValue int) int {
	return defaultValue
}

func (c *mockForgeContext) ParamInt64Default(name string, defaultValue int64) int64 {
	return defaultValue
}

func (c *mockForgeContext) ParamFloat64Default(name string, defaultValue float64) float64 {
	return defaultValue
}

func (c *mockForgeContext) ParamBoolDefault(name string, defaultValue bool) bool {
	return defaultValue
}

func (c *mockForgeContext) QueryDefault(key, defaultValue string) string {
	val := c.Request().URL.Query().Get(key)
	if val == "" {
		return defaultValue
	}
	return val
}

func (c *mockForgeContext) FormValue(key string) string {
	return c.Request().FormValue(key)
}

func (c *mockForgeContext) FormValues(key string) []string {
	return c.Request().Form[key]
}

func (c *mockForgeContext) FormFile(name string) (multipart.File, *multipart.FileHeader, error) {
	return nil, nil, nil
}

func (c *mockForgeContext) FormFiles(name string) ([]*multipart.FileHeader, error) {
	return nil, nil
}

func (c *mockForgeContext) ParseMultipartForm(maxMemory int64) error {
	return nil
}

func (c *mockForgeContext) QueryParam(key string) string {
	return c.Request().URL.Query().Get(key)
}

func (c *mockForgeContext) QueryParams() map[string][]string {
	return c.Request().URL.Query()
}

func (c *mockForgeContext) QueryString() string {
	return c.Request().URL.RawQuery
}

func (c *mockForgeContext) RealIP() string {
	return ""
}

func (c *mockForgeContext) Scheme() string {
	return "http"
}

func (c *mockForgeContext) IsTLS() bool {
	return false
}

func (c *mockForgeContext) IsWebSocket() bool {
	return false
}

func (c *mockForgeContext) Path() string {
	return c.Request().URL.Path
}

func (c *mockForgeContext) Method() string {
	return c.Request().Method
}

func (c *mockForgeContext) Host() string {
	return c.Request().Host
}

func (c *mockForgeContext) URL() string {
	return c.Request().URL.String()
}

func (c *mockForgeContext) URI() string {
	return c.Request().RequestURI
}

func (c *mockForgeContext) Protocol() string {
	return c.Request().Proto
}

func (c *mockForgeContext) HasCookie(name string) bool {
	_, err := c.Request().Cookie(name)
	return err == nil
}

func (c *mockForgeContext) GetAllCookies() map[string]string {
	cookies := make(map[string]string)
	for _, cookie := range c.Request().Cookies() {
		cookies[cookie.Name] = cookie.Value
	}
	return cookies
}

func (c *mockForgeContext) DeleteCookie(name string) {
	http.SetCookie(c.Response(), &http.Cookie{
		Name:   name,
		Value:  "",
		MaxAge: -1,
	})
}

func (c *mockForgeContext) SetCookie(name, value string, maxAge int) {
	http.SetCookie(c.Response(), &http.Cookie{
		Name:   name,
		Value:  value,
		MaxAge: maxAge,
	})
}

func (c *mockForgeContext) SetCookieWithOptions(name, value string, path, domain string, maxAge int, secure, httpOnly bool) {
	http.SetCookie(c.Response(), &http.Cookie{
		Name:     name,
		Value:    value,
		MaxAge:   maxAge,
		Path:     path,
		Domain:   domain,
		Secure:   secure,
		HttpOnly: httpOnly,
	})
}

func (c *mockForgeContext) Get(key string) interface{} {
	return c.Request().Context().Value(key)
}

func (c *mockForgeContext) Set(key string, val interface{}) {
	// Store in context if needed
}

func (c *mockForgeContext) MustGet(key string) interface{} {
	return c.Get(key)
}

func (c *mockForgeContext) Context() context.Context {
	return c.Request().Context()
}

func (c *mockForgeContext) WithContext(ctx context.Context) {
	*c.Request() = *c.Request().WithContext(ctx)
}

func (c *mockForgeContext) Container() forge.Container {
	return nil
}

func (c *mockForgeContext) Scope() forge.Scope {
	return nil
}

func (c *mockForgeContext) Resolve(name string) (any, error) {
	return nil, nil
}

func (c *mockForgeContext) Must(name string) any {
	return nil
}

// Session returns Session interface linked from internal forge package
func (c *mockForgeContext) Session() (Session, error) {
	return nil, nil
}

func (c *mockForgeContext) SetSession(session any) {
}

func (c *mockForgeContext) SaveSession() error {
	return nil
}

func (c *mockForgeContext) DestroySession() error {
	return nil
}

func (c *mockForgeContext) GetSessionValue(key string) (interface{}, bool) {
	return nil, false
}

func (c *mockForgeContext) SetSessionValue(key string, value interface{}) {
}

func (c *mockForgeContext) DeleteSessionValue(key string) {
}

func (c *mockForgeContext) SessionID() string {
	return ""
}

func (c *mockForgeContext) ClearSession() error {
	return nil
}

func (c *mockForgeContext) Flash(key string, value interface{}) {
}

func (c *mockForgeContext) GetFlash(key string) interface{} {
	return nil
}

func (c *mockForgeContext) Logger() interface{} {
	return nil
}

func (c *mockForgeContext) WithValue(key, val interface{}) forge.Context {
	return c
}

func (c *mockForgeContext) Validate(i interface{}) error {
	return nil
}

func (c *mockForgeContext) Render(code int, name string, data interface{}) error {
	return nil
}

func (c *mockForgeContext) File(file string) error {
	return nil
}

func (c *mockForgeContext) Stream(status int, contentType string, r func(w http.ResponseWriter) error) error {
	return nil
}

func (c *mockForgeContext) Attachment(file string, name string) error {
	return nil
}

func (c *mockForgeContext) Inline(file string, name string) error {
	return nil
}

func (c *mockForgeContext) XML(code int, v interface{}) error {
	return nil
}

func (c *mockForgeContext) Next() error {
	return nil
}

func (c *mockForgeContext) Error(err error) error {
	return err
}

func (c *mockForgeContext) Status(code int) interface{} {
	// Return a mock ResponseBuilder
	return nil
}

func (c *mockForgeContext) MultipartForm() (*multipart.Form, error) {
	return nil, nil
}

// Test helpers
func setupTestHandler(t *testing.T) (*Handler, *impersonation.Service, *mockImpersonationRepository, *mockUserService) {
	service, repo, userSvc, _ := setupTestService(t)
	config := DefaultConfig()
	handler := NewHandler(service, config)
	return handler, service, repo, userSvc
}

// Tests

func TestHandler_StartImpersonation_Success(t *testing.T) {
	handler, _, _, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	reqBody := impersonation.StartRequest{
		AppID:           orgID,
		ImpersonatorID:  admin.ID,
		TargetUserID:    target.ID,
		Reason:          "Customer support ticket #12345 - investigating login issue",
		TicketNumber:    "TICKET-12345",
		DurationMinutes: 30,
	}

	ctx := newMockForgeContext("POST", "/impersonation/start", reqBody)

	err := handler.StartImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	// Verify response structure
	body := ctx.GetBody().(map[string]interface{})
	assert.NotEmpty(t, body["impersonation_id"])
	assert.NotEmpty(t, body["session_id"])
	assert.NotEmpty(t, body["session_token"])
	assert.NotEmpty(t, body["expires_at"])
	assert.NotEmpty(t, body["message"])
}

func TestHandler_StartImpersonation_InvalidJSON(t *testing.T) {
	handler, _, _, _ := setupTestHandler(t)

	// Send invalid JSON
	req := httptest.NewRequest("POST", "/impersonation/start", bytes.NewReader([]byte("invalid json")))
	req.Header.Set("Content-Type", "application/json")

	mock := authsometesting.Mock{}
	ctx := &mockForgeContext{MockForgeContext: mock.NewMockForgeContext(req)}

	err := handler.StartImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 400, ctx.GetStatus())

	body := ctx.GetBody().(map[string]string)
	assert.Equal(t, "Invalid request body", body["error"])
}

func TestHandler_StartImpersonation_CannotImpersonateSelf(t *testing.T) {
	handler, _, _, userSvc := setupTestHandler(t)
	admin, _ := createTestUsers(userSvc)
	orgID := xid.New()

	reqBody := impersonation.StartRequest{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   admin.ID, // Same as impersonator
		Reason:         "Testing self impersonation",
	}

	ctx := newMockForgeContext("POST", "/impersonation/start", reqBody)

	err := handler.StartImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 400, ctx.GetStatus())

	body := ctx.GetBody().(map[string]string)
	assert.Contains(t, body["error"], "cannot impersonate yourself")
}

func TestHandler_StartImpersonation_AlreadyImpersonating(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	// Create existing active impersonation
	existingSession := &schema.ImpersonationSession{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   target.ID,
		Active:         true,
		ExpiresAt:      time.Now().Add(1 * time.Hour),
	}
	existingSession.ID = xid.New()
	existingSession.CreatedAt = time.Now()
	repo.sessions[existingSession.ID.String()] = existingSession

	reqBody := impersonation.StartRequest{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   target.ID,
		Reason:         "Testing concurrent impersonations",
	}

	ctx := newMockForgeContext("POST", "/impersonation/start", reqBody)

	err := handler.StartImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 409, ctx.GetStatus())

	body := ctx.GetBody().(map[string]string)
	assert.Contains(t, body["error"], "already impersonating")
}

func TestHandler_EndImpersonation_Success(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	// Create active impersonation
	impSession := &schema.ImpersonationSession{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   target.ID,
		Active:         true,
		ExpiresAt:      time.Now().Add(1 * time.Hour),
		Reason:         "Test impersonation",
	}
	impSession.ID = xid.New()
	impSession.CreatedAt = time.Now()
	repo.sessions[impSession.ID.String()] = impSession

	reqBody := impersonation.EndRequest{
		ImpersonationID: impSession.ID,
		AppID:           orgID,
		ImpersonatorID:  admin.ID,
		Reason:          "manual",
	}

	ctx := newMockForgeContext("POST", "/impersonation/end", reqBody)

	err := handler.EndImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(map[string]interface{})
	assert.True(t, body["success"].(bool))
	assert.NotEmpty(t, body["ended_at"])
}

func TestHandler_GetImpersonation_Success(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	// Create impersonation
	impSession := &schema.ImpersonationSession{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   target.ID,
		Active:         true,
		ExpiresAt:      time.Now().Add(1 * time.Hour),
		Reason:         "Test impersonation",
		TicketNumber:   "TICKET-123",
	}
	impSession.ID = xid.New()
	impSession.CreatedAt = time.Now()
	impSession.UpdatedAt = time.Now()
	repo.sessions[impSession.ID.String()] = impSession

	ctx := newMockForgeContext("GET", "/impersonation/"+impSession.ID.String(), nil)
	ctx.SetParam("id", impSession.ID.String())
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String()

	err := handler.GetImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.SessionInfo)
	assert.Equal(t, impSession.ID, body.ID)
	assert.Equal(t, "Test impersonation", body.Reason)
	assert.Equal(t, "TICKET-123", body.TicketNumber)
	assert.Equal(t, admin.Email, body.ImpersonatorEmail)
	assert.Equal(t, target.Email, body.TargetEmail)
}

func TestHandler_GetImpersonation_InvalidID(t *testing.T) {
	handler, _, _, _ := setupTestHandler(t)

	ctx := newMockForgeContext("GET", "/impersonation/invalid", nil)
	ctx.SetParam("id", "invalid-id")

	err := handler.GetImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 400, ctx.GetStatus())

	body := ctx.GetBody().(map[string]string)
	assert.Equal(t, "Invalid impersonation ID", body["error"])
}

func TestHandler_GetImpersonation_MissingOrgID(t *testing.T) {
	handler, _, _, _ := setupTestHandler(t)
	impID := xid.New()

	ctx := newMockForgeContext("GET", "/impersonation/"+impID.String(), nil)
	ctx.SetParam("id", impID.String())
	// No org_id in query params

	err := handler.GetImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 400, ctx.GetStatus())

	body := ctx.GetBody().(map[string]string)
	assert.Equal(t, "Organization ID is required", body["error"])
}

func TestHandler_ListImpersonations_Success(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	// Create multiple impersonations
	for i := 0; i < 3; i++ {
		session := &schema.ImpersonationSession{
			AppID:          orgID,
			ImpersonatorID: admin.ID,
			TargetUserID:   target.ID,
			Active:         true,
			ExpiresAt:      time.Now().Add(1 * time.Hour),
			Reason:         "Test session",
		}
		session.ID = xid.New()
		session.CreatedAt = time.Now()
		session.UpdatedAt = time.Now()
		repo.sessions[session.ID.String()] = session
	}

	ctx := newMockForgeContext("GET", "/impersonation", nil)
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String() + "&limit=10&offset=0"

	err := handler.ListImpersonations(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.ListSessionsResponse)
	assert.Len(t, body.Data, 3)
	assert.Equal(t, int64(3), body.Pagination.Total)
	assert.Equal(t, 10, body.Pagination.Limit)
	assert.Equal(t, 0, body.Pagination.Offset)
}

func TestHandler_ListImpersonations_WithFilters(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	otherUser := &schema.User{
		ID:    xid.New(),
		Email: "other@example.com",
		Name:  "Other User",
	}
	userSvc.users[otherUser.ID.String()] = otherUser
	orgID := xid.New()

	// Create impersonations with different targets
	for i := 0; i < 5; i++ {
		targetID := target.ID
		if i >= 3 {
			targetID = otherUser.ID
		}

		session := &schema.ImpersonationSession{
			AppID:          orgID,
			ImpersonatorID: admin.ID,
			TargetUserID:   targetID,
			Active:         true,
			ExpiresAt:      time.Now().Add(1 * time.Hour),
			Reason:         "Test session",
		}
		session.ID = xid.New()
		session.CreatedAt = time.Now()
		session.UpdatedAt = time.Now()
		repo.sessions[session.ID.String()] = session
	}

	// Filter by target user
	ctx := newMockForgeContext("GET", "/impersonation", nil)
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String() +
		"&target_user_id=" + target.ID.String() +
		"&limit=10"

	err := handler.ListImpersonations(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.ListSessionsResponse)
	assert.Len(t, body.Data, 3) // Only first 3 sessions
	assert.Equal(t, int64(3), body.Pagination.Total)
}

func TestHandler_VerifyImpersonation_Active(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()

	sessionID := xid.New()
	impSession := &schema.ImpersonationSession{
		AppID:          orgID,
		ImpersonatorID: admin.ID,
		TargetUserID:   target.ID,
		NewSessionID:   &sessionID,
		Active:         true,
		ExpiresAt:      time.Now().Add(1 * time.Hour),
	}
	impSession.ID = xid.New()
	impSession.CreatedAt = time.Now()
	repo.sessions[impSession.ID.String()] = impSession

	reqBody := impersonation.VerifyRequest{
		SessionID: sessionID,
	}

	ctx := newMockForgeContext("POST", "/impersonation/verify", reqBody)

	err := handler.VerifyImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.VerifyResponse)
	assert.True(t, body.IsImpersonating)
	assert.NotNil(t, body.ImpersonationID)
	assert.Equal(t, admin.ID, *body.ImpersonatorID)
	assert.Equal(t, target.ID, *body.TargetUserID)
}

func TestHandler_VerifyImpersonation_NotImpersonating(t *testing.T) {
	handler, _, _, _ := setupTestHandler(t)

	reqBody := impersonation.VerifyRequest{
		SessionID: xid.New(), // Non-existent
	}

	ctx := newMockForgeContext("POST", "/impersonation/verify", reqBody)

	err := handler.VerifyImpersonation(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.VerifyResponse)
	assert.False(t, body.IsImpersonating)
	assert.Nil(t, body.ImpersonationID)
}

func TestHandler_ListAuditEvents_Success(t *testing.T) {
	handler, _, repo, userSvc := setupTestHandler(t)
	admin, target := createTestUsers(userSvc)
	orgID := xid.New()
	impID := xid.New()

	// Create audit events
	for i := 0; i < 3; i++ {
		event := &schema.ImpersonationAuditEvent{
			ImpersonationID: impID,
			AppID:           orgID,
			EventType:       "test_event",
			IPAddress:       "192.168.1.1",
			UserAgent:       "Test Agent",
			Details: map[string]string{
				"target_user_id":  target.ID.String(),
				"impersonator_id": admin.ID.String(),
			},
		}
		event.ID = xid.New()
		event.CreatedAt = time.Now()
		repo.auditEvents[event.ID.String()] = event
	}

	ctx := newMockForgeContext("GET", "/impersonation/audit", nil)
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String() + "&limit=10&offset=0"

	err := handler.ListAuditEvents(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(map[string]interface{})
	events := body["events"].([]*impersonation.AuditEvent)
	assert.Len(t, events, 3)
	assert.Equal(t, 3, body["total"])
}

func TestHandler_ListAuditEvents_FilterByImpersonationID(t *testing.T) {
	handler, _, repo, _ := setupTestHandler(t)
	orgID := xid.New()
	impID1 := xid.New()
	impID2 := xid.New()

	// Create events for two different impersonations
	for i := 0; i < 5; i++ {
		impID := impID1
		if i >= 3 {
			impID = impID2
		}

		event := &schema.ImpersonationAuditEvent{
			ImpersonationID: impID,
			AppID:           orgID,
			EventType:       "test_event",
		}
		event.ID = xid.New()
		event.CreatedAt = time.Now()
		repo.auditEvents[event.ID.String()] = event
	}

	ctx := newMockForgeContext("GET", "/impersonation/audit", nil)
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String() +
		"&impersonation_id=" + impID1.String() +
		"&limit=10"

	err := handler.ListAuditEvents(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(map[string]interface{})
	events := body["events"].([]*impersonation.AuditEvent)
	assert.Len(t, events, 3) // Only first 3 events
}

func TestHandler_PaginationDefaults(t *testing.T) {
	handler, _, _, _ := setupTestHandler(t)
	orgID := xid.New()

	ctx := newMockForgeContext("GET", "/impersonation", nil)
	ctx.Request().URL.RawQuery = "org_id=" + orgID.String()
	// No limit/offset specified

	err := handler.ListImpersonations(ctx)

	require.NoError(t, err)
	assert.Equal(t, 200, ctx.GetStatus())

	body := ctx.GetBody().(*impersonation.ListSessionsResponse)
	assert.Equal(t, 20, body.Pagination.Limit) // Default limit
	assert.Equal(t, 0, body.Pagination.Offset) // Default offset
}
